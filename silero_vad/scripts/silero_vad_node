#!/usr/bin/env python

import torch
import numpy as np
from typing import List
import sys

import os.path 

import rospy
from std_srvs.srv import SetBool, SetBoolRequest, SetBoolResponse

from audio_common_msgs.msg import AudioData, AudioInfo
from std_msgs.msg import Float32, Bool


class SileroVadNode:

    def __init__(self) -> None:

        self.recording = False
        self.data: List[float] = []

        self.enabled = self.chunk = True
        self.samplerate = 16000
       
        audio_info : AudioInfo = rospy.wait_for_message('audio_info', AudioInfo, timeout=5)
        
        if not audio_info.sample_rate == self.samplerate:
            msg = f"Sample rate needs to be 16000"
            rospy.logerr(logger_name="SileroVAD", msg=msg)
            raise msg
        
        if not audio_info.channels == 1:
            msg = f"Cant use non mono audio"
            rospy.logerr(logger_name="SileroVAD", msg=msg)
            raise msg

        if audio_info.sample_format.lower() == "s16le":
            self.depth_type = np.int16
            self.nomalization = float(np.iinfo(self.depth_type).max)
        elif audio_info.sample_format.lower() == "f32le":
            self.depth_type = np.float32
            self.nomalization = None
        else:
            msg = f"unhandled audio format"
            rospy.logerr(logger_name="SileroVAD", msg=msg)
            raise msg
              
        self.init_silero()

        self._enable_srv = rospy.Service("~enable_vad", SetBool, self.enable_cb)

        self._pub = rospy.Publisher("~vad", AudioData, queue_size=10)
        self._pub_amp = rospy.Publisher("~amp", Float32, queue_size=10)
        self._pub_rec = rospy.Publisher("~in_rec", Bool, queue_size=1, latch=True)
        self._pub_enabled = rospy.Publisher("~enabled", Bool, queue_size=1, latch=True)
        self._sub = rospy.Subscriber(
            "audio",
            AudioData,
            self.audio_cb,
        )

        self._pub_enabled.publish(True)

        self.one_more = False
        self.prebuf = []

        rospy.loginfo(logger_name="SileroVAD", msg=f"Silero VAD node started")

    def audio_cb(self, msg: AudioData) -> None:

        if not self.enabled:
            return

        audio = np.frombuffer(msg.data, dtype=self.depth_type)
        if not self.nomalization is None:
            amp = np.max(audio.astype(np.float32, order="C")) / self.nomalization
            amp_msg = Float32()
            amp_msg.data = amp
        else:
            amp = np.max(audio.astype(np.float32, order="C"))
            amp_msg = Float32()
            amp_msg.data = amp
        
        #print(amp_msg.data)
        self._pub_amp.publish(amp_msg)

        if len(self.prebuf) == 0:
            self.prebuf = audio
            return
        else:
            self.prebuf = np.concatenate((self.prebuf, audio))

        vals = self.samplerate / self.prebuf.shape[0]
        # we dont have 33ms of date
        if vals > 33:
            return

        if not self.nomalization is None:
            floats = self.prebuf.astype(np.float32, order="C") / self.nomalization
        else:
            floats = self.prebuf.astype(np.float32, order="C")

        speech_dict = self.vad_iterator(torch.from_numpy(floats))

        if speech_dict:
            if not self.recording and "start" in speech_dict:
                self.start_time = speech_dict["start"]
                self.recording = True
                self.data = self.prebuf
                self.prebuf = []
                self._pub_rec.publish(True)
                return

            elif self.recording and "end" in speech_dict:
                self.end_time = speech_dict["end"]
                rospy.loginfo(logger_name="SileroVAD", msg=f"recorded speech segment: {self.end_time - self.start_time}")
                self.recording = False
                self.data = np.concatenate((self.data, self.prebuf))
                vad_msg = AudioData()
                vad_msg.data = self.data.tobytes()
                self._pub.publish(vad_msg)
                self.prebuf = []
                self.vad_iterator.reset_states() # reset model states after each audio

        if self.recording:
            self.data = np.concatenate((self.data, self.prebuf))

        self._pub_rec.publish(self.recording)
        self.prebuf = []

    def init_silero(self) -> None:
        try:
            # try loading from cache
            import sys
            cache = os.path.abspath(os.path.expanduser("~/.cache/torch/hub/snakers4_silero-vad_master"))
            sys.path.append(cache)
            from utils_vad import (
                       get_speech_timestamps,
                       save_audio,
                       read_audio,
                       VADIterator,
                       collect_chunks,
                       OnnxWrapper)
            model_dir = os.path.join(cache, 'files')
            model = OnnxWrapper(os.path.join(model_dir, 'silero_vad.onnx'), False)
            utils = (get_speech_timestamps,
                save_audio,
                read_audio,
                VADIterator,
                collect_chunks
            )
            rospy.loginfo(logger_name="SileroVAD", msg=f"loaded model from cache")
        except Exception as e:
            rospy.loginfo(logger_name="SileroVAD", msg=f"loading from cache failed...")
            model, utils = torch.hub.load(
                repo_or_dir="snakers4/silero-vad",
                model="silero_vad",
                force_reload=False,
                onnx=True,
            )

        (_, _, _, VADIterator, _) = utils
        self.vad_iterator = VADIterator(model)

    def enable_cb(self, req: SetBoolRequest):
        res = SetBoolResponse()
        res.success = True
        self.enabled = req.data

        if self.enabled:
            res.message = "Silero enabled"
        else:
            res.message = "Silero disabled"
            self.recording = False
            self.data = []
            self.vad_iterator.reset_states()

        rospy.loginfo(logger_name="SileroVAD", msg=f"{res.message}")
        self._pub_enabled.publish(self.enabled)
        return res


def main():
    rospy.init_node("silero_vad")
    node = SileroVadNode()
    rospy.spin()


if __name__ == "__main__":
    main()
