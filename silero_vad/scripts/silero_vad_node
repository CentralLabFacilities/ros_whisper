#!/usr/bin/env python

import torch
import numpy as np
from typing import List
import sys

import os.path

import rospy
from std_srvs.srv import SetBool, SetBoolRequest, SetBoolResponse

from audio_common_msgs.msg import AudioData, AudioInfo
from std_msgs.msg import Float32, Bool

from clf_speech_msgs.srv import SetFloat32, SetFloat32Request, SetFloat32Response


class SileroVadNode:

    def __init__(self, start_amp=0.5) -> None:

        self.recording = False
        self.data: List[float] = []
        self.start_amp = start_amp

        self.enabled = self.chunk = True
        self.samplerate = 16000

        rospy.loginfo(logger_name="SileroVAD", msg=f"waiting for audio_info...")
        audio_info: AudioInfo = rospy.wait_for_message(
            "audio_info", AudioInfo, timeout=10
        )

        if not audio_info.sample_rate == self.samplerate:
            msg = f"Sample rate needs to be 16000"
            rospy.logerr(logger_name="SileroVAD", msg=msg)
            raise msg

        if not audio_info.channels == 1:
            msg = f"Cant use non mono audio"
            rospy.logerr(logger_name="SileroVAD", msg=msg)
            raise msg

        if audio_info.sample_format.lower() == "s16le":
            self.depth_type = np.int16
            self.nomalization = float(np.iinfo(self.depth_type).max)
        elif audio_info.sample_format.lower() == "f32le":
            self.depth_type = np.float32
            self.nomalization = None
        else:
            msg = f"unhandled audio format"
            rospy.logerr(logger_name="SileroVAD", msg=msg)
            raise msg

        rospy.loginfo(
            logger_name="SileroVAD", msg=f"normalization: {self.nomalization}"
        )

        self.init_silero()

        self._enable_srv = rospy.Service("~enable_vad", SetBool, self.enable_cb)
        self._min_amp_srv = rospy.Service(
            "~set_min_amp", SetFloat32, self.set_min_amp_cb
        )

        self._pub = rospy.Publisher("~vad", AudioData, queue_size=10)
        self._pub_amp = rospy.Publisher("~amp", Float32, queue_size=10)
        self._pub_rec = rospy.Publisher("~in_rec", Bool, queue_size=1, latch=True)
        self._pub_min_amp = rospy.Publisher(
            "~min_amp", Float32, queue_size=1, latch=True
        )
        amp_msg = Float32()
        amp_msg.data = self.start_amp
        self._pub_min_amp.publish(amp_msg)
        self._pub_enabled = rospy.Publisher("~enabled", Bool, queue_size=1, latch=True)
        self._sub = rospy.Subscriber(
            "audio",
            AudioData,
            self.audio_cb,
        )

        self._pub_enabled.publish(True)

        self.one_more = False
        self.prebuf = []
        self.lastbuf = np.array([], dtype=np.float32)

        rospy.loginfo(logger_name="SileroVAD", msg=f"Silero VAD node started")

    def audio_cb(self, msg: AudioData) -> None:

        if not self.enabled:
            return

        audio = np.frombuffer(msg.data, dtype=self.depth_type)

        if len(self.prebuf) == 0:
            self.prebuf = audio
            return
        else:
            self.prebuf = np.append(self.prebuf, audio)

        vals = self.samplerate / self.prebuf.shape[0]
        # we dont have 33ms of data
        if vals > 30:
            return

        if not self.nomalization is None:
            floats = self.prebuf.astype(np.float32, order="C") / self.nomalization
        else:
            floats = self.prebuf.astype(np.float32, order="C")

        amp = np.max(floats)
        amp_msg = Float32()
        amp_msg.data = amp

        # print(amp_msg.data)
        self._pub_amp.publish(amp_msg)

        # Dont start recording until min amplitute is reached?
        if not self.recording and amp < self.start_amp:
            speech_dict = False
        else:
            speech_dict = self.vad_iterator(torch.from_numpy(floats))

        if speech_dict:
            if not self.recording and "start" in speech_dict:
                self.start_time = speech_dict["start"]
                self.recording = True
                self.data = self.lastbuf
                self.data = np.append(self.data, self.prebuf)
                self.prebuf = []
                self.lastbug = []
                self._pub_rec.publish(True)
                return

            elif self.recording and "end" in speech_dict:
                self.end_time = speech_dict["end"]
                rospy.loginfo(
                    logger_name="SileroVAD",
                    msg=f"recorded speech segment: {self.end_time - self.start_time}",
                )
                self.recording = False
                self.data = np.append(self.data, self.prebuf)
                vad_msg = AudioData()
                vad_msg.data = self.data.tobytes()
                self._pub.publish(vad_msg)
                self.prebuf = []
                self.vad_iterator.reset_states()  # reset model states after each audio

        if self.recording:
            self.data = np.append(self.data, self.prebuf)

        self._pub_rec.publish(self.recording)
        self.lastbuf = self.prebuf
        self.prebuf = []

    def init_silero(self) -> None:
        try:
            # try loading from cache
            import sys

            cache = os.path.abspath(
                os.path.expanduser("~/.cache/torch/hub/snakers4_silero-vad_master")
            )
            sys.path.append(cache)
            from utils_vad import (
                get_speech_timestamps,
                save_audio,
                read_audio,
                VADIterator,
                collect_chunks,
                OnnxWrapper,
            )

            model_dir = os.path.join(cache, "files")
            model = OnnxWrapper(os.path.join(model_dir, "silero_vad.onnx"), False)
            utils = (
                get_speech_timestamps,
                save_audio,
                read_audio,
                VADIterator,
                collect_chunks,
            )
            rospy.loginfo(logger_name="SileroVAD", msg=f"loaded model from cache")
        except Exception as e:
            rospy.loginfo(logger_name="SileroVAD", msg=f"loading from cache failed...")
            model, utils = torch.hub.load(
                repo_or_dir="snakers4/silero-vad",
                model="silero_vad",
                force_reload=False,
                onnx=True,
            )

        (_, _, _, VADIterator, _) = utils
        self.vad_iterator = VADIterator(model)

    def enable_cb(self, req: SetBoolRequest):
        res = SetBoolResponse()
        res.success = True
        self.enabled = req.data

        if self.enabled:
            res.message = "Silero enabled"
        else:
            res.message = "Silero disabled"
            self.recording = False
            self.data = []
            self.vad_iterator.reset_states()

        rospy.loginfo(logger_name="SileroVAD", msg=f"{res.message}")
        self._pub_enabled.publish(self.enabled)
        return res

    def set_min_amp_cb(self, req: SetFloat32Request):
        res = SetFloat32Response()
        if req.data > 1.0 or req.data < 0.0:
            res.success = False
        else:
            res.success = True

        self.start_amp = req.data
        res.message = f"set min amp to {self.start_amp }"

        amp_msg = Float32()
        amp_msg.data = self.start_amp

        self._pub_min_amp.publish(amp_msg)

        rospy.loginfo(logger_name="SileroVAD", msg=f"{res.message}")
        self._pub_enabled.publish(self.enabled)
        return res


def main():
    rospy.init_node("silero_vad")
    start_amp = rospy.get_param("~start_amp", 0.0)
    node = SileroVadNode(start_amp)
    rospy.spin()


if __name__ == "__main__":
    main()
